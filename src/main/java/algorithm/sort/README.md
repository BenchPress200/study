# Sort

### 🫧 Bubble Sort

> [!NOTE]
> 두 인접 데이터의 크기를 비교해 정렬하는 알고리즘입니다. worst case에서 O(n^2)의 시간복잡도를 필요로 합니다.

##### How to Implement
1. 비교 연산을 진행할 초기 범위 설정
2. 인접 데이터 비교
3. swap 조건에 부합하면 swap 수행
4. 설정한 범위가 끝날 때까지 2 ~ 3 반복
5. 설정한 범위--
6. 설정 범위가 0이 될 때까지 1 ~ 5 반복

위 방식에서는 이미 정렬된 상태라도 모두 검사를 진행하기 때문에 worst case와 best case 둘 다 O(n^2)의 시간복잡도를 가집니다. 설정한 범위에서 반복문을 끝났을 때 스왑여부를 체크하여 조기 종료를 한다면 best case에서 O(n)의 시간복잡도를 가질 수 있습니다.


<br>

### ⊕ Selection Sort

> [!NOTE]
> 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 알고리즘입니다. 선택 정렬의 시간 복잡도는 O(n^2) 입니다.
 
##### How to Implement
1. 남은 정렬 범위 설정
2. 설정한 범위에서에서 가장 앞 데이터와 선택된 데이터(최대 or 최소) swap
3. 남은 정렬 범위 축소
4. 남은 정렬 범위가 없을 때까지 반복

<br>

### 🌬️ Insertion Sort

> [!NOTE]
> 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 알고리즘입니다. 삽입 정렬의 시간 복잡도는 O(n^2) 입니다.

##### How to Implement
1. 현재 index 데이터 선택
2. 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치 탐색
3. 삽입위치를 찾았으면 shift 연산으로 밀어내기
4. index++
5. index 끝날 때까지 반복

<br>

### 🏃🏻 Quick Sort

> [!NOTE]
> 기준값을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘입니다. average case의 시간 복잡도는 O(nlogn), worst case의 시간 복잡도는 O(n^2) 입니다.
> 

##### How to Implement
1. 데이터를 분할하는 pivot 설정
   - 랜덤 설정 가능
2. pivot을 기준으로 다음 아래 과정을 거쳐 데이터를 2개의 집합으로  분리
   1. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start 오른쪽 한 칸 이동
   2. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 한 칸 이동
   3. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터 swap하고 start는 오른쪽, end는 왼쪽으로 한 칸씩 이동
   4. start와 end가 만날 때까지 i ~ iii 반복
3. 분리 집합에서 각각 다시 pivot 선정
4. 분리 집합이 1개 이하가 될 때까지 1 ~ 3 반복
